{"ast":null,"code":"import _asyncToGenerator from \"D:\\\\Repositories\\\\Web-Projects\\\\Lynx (MEAN)\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n      throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = yield getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n\n    for (let i = 0; i < length; i += 128) {\n      if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n          for (let k = 0; k < options.channelCount; k += 1) {\n            copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n          }\n        }\n      }\n\n      if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n        processorConstructor.parameterDescriptors.forEach(({\n          name\n        }, index) => {\n          copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n        });\n      }\n\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n          // The byteLength will be 0 when the ArrayBuffer was transferred.\n          if (outputs[j][k].byteLength === 0) {\n            outputs[j][k] = new Float32Array(128);\n          }\n        }\n      }\n\n      try {\n        const potentiallyEmptyInputs = inputs.map((input, index) => {\n          if (audioNodeConnections.activeInputs[index].size === 0) {\n            return [];\n          }\n\n          return input;\n        });\n        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n        if (processedBuffer !== null) {\n          for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n            }\n\n            outputChannelSplitterNodeOutput += outputChannelCount[j];\n          }\n        }\n\n        if (!activeSourceFlag) {\n          break;\n        }\n      } catch (error) {\n        proxy.dispatchEvent(new ErrorEvent('processorerror', {\n          colno: error.colno,\n          filename: error.filename,\n          lineno: error.lineno,\n          message: error.message\n        }));\n        break;\n      }\n    }\n\n    return processedBuffer;\n  });\n\n  return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (proxy, nativeOfflineAudioContext) {\n        let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n        let nativeOutputNodes = null;\n        const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n        const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n\n        if (nativeAudioWorkletNodeConstructor === null) {\n          const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n          const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n          });\n          const outputChannelMergerNodes = [];\n\n          for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: outputChannelCount[i]\n            }));\n          }\n\n          const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: options.channelCount,\n            channelCountMode: options.channelCountMode,\n            channelInterpretation: options.channelInterpretation,\n            gain: 1\n          });\n          outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n          outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n          nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n        } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n          nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n        }\n\n        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n        if (nativeOutputNodes !== null) {\n          if (processedBufferPromise === null) {\n            if (processorConstructor === undefined) {\n              throw new Error('Missing the processor constructor.');\n            }\n\n            if (nativeOfflineAudioContextConstructor === null) {\n              throw new Error('Missing the native OfflineAudioContext constructor.');\n            } // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n\n\n            const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n            const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n            const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n            const renderBuffer = /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator(function* () {\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n                // Bug #17: Safari does not yet expose the length.\n                Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                const gainNodes = [];\n                const inputChannelSplitterNodes = [];\n\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                  gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                  }));\n                  inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                  }));\n                }\n\n                const constantSourceNodes = yield Promise.all(Array.from(proxy.parameters.values()).map( /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator(function* (audioParam) {\n                    const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                      channelCount: 1,\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'discrete',\n                      offset: audioParam.value\n                    });\n                    yield renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                    return constantSourceNode;\n                  });\n\n                  return function (_x10) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }()));\n                const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                  channelCount: 1,\n                  channelCountMode: 'explicit',\n                  channelInterpretation: 'speakers',\n                  numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                });\n\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                  gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                  for (let j = 0; j < options.channelCount; j += 1) {\n                    inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                  }\n                }\n\n                for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                  constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                  constantSourceNode.start(0);\n                }\n\n                inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                yield Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n                return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n              });\n\n              return function renderBuffer() {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n\n            processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : yield renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n          }\n\n          const processedBuffer = yield processedBufferPromise;\n          const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n          });\n          const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n          if (processedBuffer !== null) {\n            audioBufferSourceNode.buffer = processedBuffer;\n            audioBufferSourceNode.start(0);\n          }\n\n          audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n          for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n            const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n            for (let j = 0; j < outputChannelCount[i]; j += 1) {\n              outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n            }\n\n            outputChannelSplitterNodeOutput += outputChannelCount[i];\n          }\n\n          return outputGainNode;\n        }\n\n        if (!nativeAudioWorkletNodeIsOwnedByContext) {\n          for (const [nm, audioParam] of proxy.parameters.entries()) {\n            yield renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm));\n          }\n        } else {\n          for (const [nm, audioParam] of proxy.parameters.entries()) {\n            yield connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm));\n          }\n        }\n\n        yield renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n        return nativeAudioWorkletNode;\n      });\n\n      return function createAudioNode(_x8, _x9) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["D:/Repositories/Web-Projects/Lynx (MEAN)/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"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","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}